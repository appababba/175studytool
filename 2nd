<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bioinformatics Final Review Game</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            background-color: #2c3e50; /* Dark blue-grey background */
            color: #ecf0f1; /* Light text color */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            width: 100%;
            max-width: 700px; /* Slightly narrower for screenshot style */
            background: #34495e; /* Darker container background */
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            text-align: center;
        }
        h1 {
            color: #3498db; /* Bright blue for title */
            margin-bottom: 25px;
        }
        .question-area {
            margin-bottom: 20px;
            padding: 20px;
            background-color: #46627f; /* Slightly lighter question box */
            border-radius: 8px;
            text-align: left;
        }
        .question-text {
            font-size: 1.15em; /* Adjusted for style */
            margin-bottom: 10px;
        }
        .question-source {
            font-size: 0.8em;
            color: #bdc3c7; /* Lighter grey for source */
            margin-bottom: 10px;
        }
        .answer-prompt {
            font-style: italic;
            color: #bdc3c7;
            margin-bottom: 15px;
        }
        .answer-input {
            width: calc(100% - 24px);
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #56708c;
            border-radius: 6px;
            background-color: #2c3e50; /* Dark input background */
            color: #ecf0f1; /* Light text in input */
            font-size: 1em;
        }
        .answer-input::placeholder {
            color: #7f8c8d;
        }
        .button {
            padding: 12px 20px;
            margin: 8px 5px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
            width: calc(50% - 12px); /* For two buttons side-by-side */
            box-sizing: border-box;
        }
        .button.full-width {
            width: 100%;
        }
        .submit-btn { background-color: #3498db; color: white; }
        .submit-btn:hover { background-color: #2980b9; }
        .show-answer-btn { background-color: #1abc9c; color: white; }
        .show-answer-btn:hover { background-color: #16a085; }
        .correct-btn { background-color: #2ecc71; color: white; }
        .correct-btn:hover { background-color: #27ae60; }
        .incorrect-btn { background-color: #e74c3c; color: white; }
        .incorrect-btn:hover { background-color: #c0392b; }
        .next-btn { background-color: #95a5a6; color: white; }
        .next-btn:hover { background-color: #7f8c8d; }

        .button-group {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        .feedback-area {
            margin-top: 20px;
            padding: 15px;
            border-radius: 6px;
            font-weight: bold;
        }
        .feedback-correct { background-color: rgba(46, 204, 113, 0.2); color: #2ecc71; border: 1px solid #2ecc71; }
        .feedback-incorrect { background-color: rgba(231, 76, 60, 0.2); color: #e74c3c; border: 1px solid #e74c3c; }
        
        .correct-answer-display {
            margin-top: 15px;
            padding: 15px;
            background-color: #46627f; /* Consistent with question box */
            border: 1px solid #56708c;
            border-radius: 6px;
            text-align: left;
        }
        .correct-answer-display h4 { margin-top: 0; color: #3498db; }

        .stats-area, .skip-area {
            margin-top: 25px;
            padding: 15px;
            background-color: #46627f; /* Consistent background */
            border-radius: 8px;
            font-size: 0.9em;
            color: #bdc3c7;
        }
        .stats-area p, .skip-area p { margin: 8px 0; }
        .stats-area span { font-weight: bold; color: #ecf0f1; }
        #skipToQuestionSelect {
            padding: 8px;
            border-radius: 4px;
            background-color: #2c3e50;
            color: #ecf0f1;
            border: 1px solid #56708c;
            margin-left: 10px;
        }
        .footer {
            margin-top: 30px;
            font-size: 0.8em;
            color: #7f8c8d;
        }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Bioinformatics</h1>
        
        <div id="game-area">
            <div class="question-area">
                <p class="question-source" id="questionSource">Source: N/A</p>
                <p class="question-text" id="questionText">Loading question...</p>
                <p class="answer-prompt" id="answerPrompt"></p>
                <div id="noteArea" class="answer-prompt"></div>
            </div>

            <div id="input-area">
                <input type="text" id="answerInput" class="answer-input" placeholder="Type your answer">
                <button id="submitAnswerBtn" class="button full-width submit-btn">Submit Answer</button>
            </div>

            <button id="showAnswerBtn" class="button full-width show-answer-btn">Show Correct Answer</button>
            
            <div id="correctAnswerDisplay" class="correct-answer-display hidden">
                <h4>Correct Answer:</h4>
                <p id="correctAnswerText"></p>
            </div>

            <div id="self-assessment-area" class="button-group hidden">
                <button id="markCorrectBtn" class="button correct-btn">Got it Right!</button>
                <button id="markIncorrectBtn" class="button incorrect-btn">Need Practice</button>
            </div>
            
            <div id="feedbackArea" class="feedback-area hidden"></div>
            <button id="nextQuestionBtn" class="button full-width next-btn hidden">Next Question</button>
        </div>

        <div class="stats-area">
            <p>Question Progress: <span id="questionProgress">0 / 0</span> (Current Round)</p>
            <p>Priority Review Queue: <span id="priorityQueueSize">0</span></p>
            <p>Overall Score: <span id="overallScore">0 / 0</span> (Session Total)</p>
        </div>

        <div class="skip-area">
            <label for="skipToQuestionSelect">Skip to Question:</label>
            <select id="skipToQuestionSelect"></select>
        </div>
        <p class="footer">Happy Studying! Inspired by the Math Academy Way.</p>
    </div>

    <script>
        const questions = [
            // Tier 1: Foundational Concepts
            {
                id: 'fr_what_is_bioinformatics', tier: 1, source: 'General Prerequisite',
                questionText: "What is Bioinformatics?",
                correctAnswerDetail: "Bioinformatics is an interdisciplinary field that develops methods and software tools for understanding biological data. It combines biology, computer science, information engineering, mathematics, and statistics to analyze and interpret biological information, particularly large and complex data sets like genomic sequences, protein structures, and gene expression data.",
                answerType: 'self_assessed_descriptive', tags: ['definitions', 'bioinformatics_basics']
            },
            {
                id: 'ex1_1a', tier: 1, source: 'Exam 1, Q1a',
                questionText: "Explain briefly 'splicing' in the gene expression.",
                correctAnswerDetail: "Splicing is the process in eukaryotic gene expression where introns (non-coding regions) are removed from the pre-mRNA, and exons (coding regions) are joined together to form mature mRNA.",
                answerType: 'self_assessed_descriptive', tags: ['biology_primer', 'splicing', 'exam1']
            },
            {
                id: 'ex1_1d', tier: 1, source: 'Exam 1, Q1d',
                questionText: "What is the role of tRNA (transfer RNA), which is a non-coding RNA?",
                correctAnswerDetail: "Transfer RNA (tRNA) acts as an adaptor molecule in protein synthesis. It matches a specific codon on the mRNA with its corresponding amino acid, carrying that amino acid to the ribosome for protein assembly.",
                answerType: 'self_assessed_descriptive', tags: ['biology_primer', 'trna', 'translation', 'exam1']
            },
            {
                id: 'fr_blast_seeding_rationale', tier: 1, source: 'Final Review - BLAST',
                questionText: "What is the rationale for using 'seeding' in heuristic local alignment algorithms like BLAST?",
                correctAnswerDetail: "Seeding quickly identifies short, highly similar regions (seeds) between sequences. This allows BLAST to focus intensive alignment extension steps only around these promising regions, greatly speeding up searches in large databases by avoiding full comparisons for every sequence pair.",
                answerType: 'self_assessed_descriptive', tags: ['blast', 'seeding', 'final_review']
            },
            {
                id: 'fr_blast_evalue', tier: 1, source: 'Final Review - BLAST',
                questionText: "Define E-value (Expect value) in the context of BLAST.",
                correctAnswerDetail: "The E-value represents the number of distinct alignments with a score equal to or greater than the observed score that would be expected to occur purely by chance when searching a database of a particular size. A lower E-value indicates a more statistically significant match.",
                answerType: 'self_assessed_descriptive', tags: ['blast', 'statistics', 'e_value', 'final_review']
            },
             {
                id: 'ex2_1a', tier: 1, source: 'Exam 2, Q1a',
                questionText: "Define the motif finding problem.",
                correctAnswerDetail: "The motif finding problem is to identify short, recurring patterns (L-mers or motifs) of a specific length (L) within a collection of biological sequences that are statistically overrepresented or highly conserved, presumed to have biological significance.",
                answerType: 'self_assessed_descriptive', tags: ['motif_finding', 'definitions', 'exam2']
            },
            {
                id: 'fr_gene_pred_stat_vs_sim', tier: 1, source: 'Final Review - Gene Prediction',
                questionText: "Briefly, what are the two main approaches to gene prediction mentioned in the review?",
                correctAnswerDetail: "1. Statistical approach: Locating splicing signals (e.g., AG-Exon-GT) and other statistical patterns characteristic of genes.\n2. Similarity-based approach: Finding similarities between a new genome and known protein or mRNA sequences to identify potential exons.",
                answerType: 'self_assessed_descriptive', tags: ['gene_prediction', 'definitions', 'final_review']
            },
            {
                id: 'fr_rnaseq_rpkm_fpkm_purpose', tier: 1, source: 'Final Review - RNA-seq',
                questionText: "What is the main purpose of using RPKM (or FPKM) in RNA-seq analysis?",
                correctAnswerDetail: "RPKM/FPKM are used to normalize read counts to account for biases due to sequencing depth (total number of reads) and gene/transcript length, allowing for more comparable measures of gene expression levels across different genes and samples.",
                answerType: 'self_assessed_descriptive', tags: ['rna_seq', 'normalization', 'rpkm', 'fpkm', 'final_review']
            },
            {
                id: 'fr_trees_suffix_vs_keyword', tier: 1, source: 'Final Review - Suffix/Keyword Trees',
                questionText: "What's the key difference in how Suffix Trees and Keyword Trees (like Aho-Corasick) are built and used for pattern matching?",
                correctAnswerDetail: "Suffix Tree: Built from a single text/reference; used to search for many different patterns within that one text.\nKeyword Tree: Built from a set of multiple patterns (keywords); used to find occurrences of those specific patterns in any given text.",
                answerType: 'self_assessed_descriptive', tags: ['data_structures', 'string_matching', 'final_review']
            },


            // Tier 2: Core Exam Applications / Algorithms
            {
                id: 'ex1_1b', tier: 2, source: 'Exam 1, Q1b',
                questionText: "Describe the typical structure of a mature eukaryotic mRNA, specifying each key field/region with its name.",
                correctAnswerDetail: "A mature eukaryotic mRNA typically consists of: \n1. 5' Cap (modified guanine)\n2. 5' Untranslated Region (5' UTR)\n3. Coding Region (CDS - starts with start codon, ends with stop codon)\n4. 3' Untranslated Region (3' UTR)\n5. Poly-A Tail (string of adenine nucleotides)",
                answerType: 'self_assessed_descriptive', tags: ['biology_primer', 'mrna', 'exam1']
            },
            {
                id: 'ex1_3a_combined', tier: 2, source: 'Exam 1, Q3a',
                questionText: "Briefly explain the core idea behind: 1. Greedy algorithms, 2. Branch-and-bound algorithms, and 3. Dynamic programming algorithms.",
                correctAnswerDetail: "1. Greedy: Makes the locally optimal choice at each step hoping for a global optimum.\n2. Branch-and-Bound: Systematically enumerates solutions, pruning branches that cannot lead to a better solution than already found using bounds.\n3. Dynamic Programming: Solves complex problems by breaking them into simpler, overlapping subproblems, solving each subproblem once and storing its solution.",
                answerType: 'self_assessed_descriptive', tags: ['algorithms', 'definitions', 'exam1']
            },
            {
                id: 'ex1_3b', tier: 2, source: 'Exam 1, Q3b',
                questionText: "What is a 'polynomial time algorithm'? Express this using Big-O notation.",
                correctAnswerDetail: "A polynomial time algorithm is one whose execution time is bounded by a polynomial function of the input size 'n'. In Big-O notation, this is O(n^c), where 'c' is a positive constant.",
                correctAnswerExact: "O(n^c)",
                answerType: 'short_answer_flexible', tags: ['algorithms', 'complexity', 'big_o', 'exam1']
            },
            {
                id: 'ex1_4a', tier: 2, source: 'Exam 1, Q4a',
                questionText: "Define the Restriction Site Mapping Problem (Partial Digest Problem - PDP) in terms of its input and output.",
                correctAnswerDetail: "Input: A multiset L (or ΔX) of fragment lengths from a partial digest, including all pairwise distances between restriction sites, distances from start (0) to all sites, and the total length M.\nOutput: A set X = {x_1, ..., x_n} of restriction site positions (0 = x_1 < ... < x_n = M) such that the multiset of all distances |x_j - x_i| (for i < j) equals L.",
                answerType: 'self_assessed_descriptive', tags: ['algorithms', 'pdp', 'exam1']
            },
            {
                id: 'ex2_1b', tier: 2, source: 'Exam 2, Q1b',
                questionText: "What is the formula for the total searching space (number of choices) for motif finding, given: p DNA sequences, each with length k, and L-mer length L?",
                correctAnswerDetail: "The total searching space is (k - L + 1)^p.",
                correctAnswerExact: "(k-L+1)^p",
                answerType: 'short_answer_formula', tags: ['motif_finding', 'complexity', 'exam2']
            },
            {
                id: 'ex2_4a', tier: 2, source: 'Exam 2, Q4a',
                questionText: "Write the recurrence relation for computing V(i,j) in the Needleman-Wunsch global alignment algorithm (assume linear gap penalty 'g' and match/mismatch score s(char1, char2)).",
                correctAnswerDetail: "V(i,j) = max { V(i-1, j-1) + s(S1[i], S2[j]), V(i-1, j) + g, V(i, j-1) + g }.\nBase cases: V(0,0) = 0; V(i,0) = i*g; V(0,j) = j*g.",
                answerType: 'self_assessed_descriptive', tags: ['sequence_alignment', 'global_alignment', 'needleman_wunsch', 'exam2']
            },
            {
                id: 'ex2_4b', tier: 2, source: 'Exam 2, Q4b',
                questionText: "How is the Longest Common Subsequence (LCS) problem described in terms of global alignment, including the scoring scheme?",
                correctAnswerDetail: "LCS can be found using global alignment (Needleman-Wunsch) with: Match score = +1; Mismatch penalty = 0 (or -infinity if mismatches are disallowed in the common subsequence itself); Gap penalty = 0. The score of the optimal alignment gives the LCS length.",
                answerType: 'self_assessed_descriptive', tags: ['sequence_alignment', 'lcs', 'exam2']
            },
            {
                id: 'ex2_5a', tier: 2, source: 'Exam 2, Q5a',
                questionText: "Provide the formula for an Affine gap penalty for a gap of length k, and describe how a linear gap penalty model relates to it.",
                correctAnswerDetail: "Affine gap penalty for a gap of length k: P(k) = -(GapOpen + (k-1) * GapExtension). (Assuming GapOpen and GapExtension are positive costs).\nA linear gap penalty model is a special case of the affine model where GapOpen = 0. So, P(k) = -(k * GapExtension).",
                answerType: 'self_assessed_descriptive', tags: ['sequence_alignment', 'gap_penalty', 'exam2']
            },
            {
                id: 'fr_exon_chaining_problem_def', tier: 2, source: 'Final Review - Gene Prediction',
                questionText: "What is the Exon Chaining Problem in gene prediction?",
                correctAnswerDetail: "Given a set of putative exons (weighted intervals representing similarity to a target protein/cDNA on a genome), the Exon Chaining Problem is to find a subset of these exons that are non-overlapping, ordered correctly, and maximize a total score (sum of individual exon scores, possibly with intron scores/penalties). This chain represents the predicted gene structure.",
                answerType: 'self_assessed_descriptive', tags: ['gene_prediction', 'exon_chaining', 'final_review']
            },
            {
                id: 'fr_rnaseq_rpkm_formula_def', tier: 2, source: 'Final Review - RNA-seq',
                questionText: "Write down the formula for RPKM (Reads Per Kilobase of exon model per Million mapped reads).",
                correctAnswerDetail: "RPKM = (Number of reads mapped to a gene * 10^9) / (Gene length in base pairs * Total number of mapped reads in the sample)",
                correctAnswerExact: "(num_reads * 10^9) / (gene_length_bp * total_mapped_reads)",
                answerType: 'short_answer_formula', tags: ['rna_seq', 'normalization', 'rpkm', 'final_review']
            },

            // Tier 3: Complex Exam Problems / Specific Calculations
            {
                id: 'ex1_1c', tier: 3, source: 'Exam 1, Q1c',
                questionText: "Using a standard genetic code table, translate the CDS: ATCTCGCTAATTTAA into a protein sequence (single-letter amino acid codes). Indicate where it stops.",
                note: "The exam question implied TAA is a stop codon.",
                correctAnswerDetail: "ATC = I (Isoleucine)\nTCG = S (Serine)\nCTA = L (Leucine)\nATT = I (Isoleucine)\nTAA = STOP codon.\nProtein sequence: ISLI. Stops after Isoleucine (ATT).",
                correctAnswerExact: "ISLI",
                answerType: 'short_answer_flexible', tags: ['biology_primer', 'translation', 'exam1']
            },
            {
                id: 'ex1_2_combined', tier: 3, source: 'Exam 1, Q2',
                questionText: "From Exam 1, Q2: gene1 (chr-xx, 5, 12, ..., '-') had sequence GGATCTAA. gene2 (chr-xx, 10, 16, ..., '+') had sequence CTACAGG. (Focus on recalling these results for this question).",
                note: "This tests recall of the specific exam problem's answers. Actual derivation requires the provided FASTA and careful BED interpretation.",
                correctAnswerDetail: "For gene1 (strand '-'), the exam answer was GGATCTAA.\nFor gene2 (strand '+'), the exam answer was CTACAGG.",
                correctAnswerExact: "gene1: GGATCTAA, gene2: CTACAGG",
                answerType: 'self_assessed_descriptive', tags: ['sequence_extraction', 'exam1']
            },
            {
                id: 'ex1_4b_recall', tier: 3, source: 'Exam 1, Q4b',
                questionText: "Recall the key steps outlined in Exam 1 for the brute-force algorithm for the PDP (Partial Digest Problem).",
                correctAnswerDetail: "1. M = maximum value in L (multiset of fragment lengths).\n2. Initialize X = {0, M} (set of cut sites).\n3. For every set of (n-2) integers xi chosen appropriately (e.g., from L or values < M):\n    a. Form a candidate set of sites X_candidate by adding these xi to {0, M} and sorting.\n    b. Form ΔX_candidate: the multiset of all pairwise distances from X_candidate.\n    c. If ΔX_candidate equals L, return X_candidate.",
                answerType: 'self_assessed_descriptive', tags: ['algorithms', 'pdp', 'exam1']
            },
            {
                id: 'ex1_5ab_recall', tier: 3, source: 'Exam 1, Q5a & Q5b',
                questionText: "For the practical PDP algorithm (Exam 1, Q5): a) How is a hypothetical next cut site $x_i$ typically chosen? b) How is it checked for satisfactoriness?",
                correctAnswerDetail: "a) Choosing $x_i$: Select the largest remaining fragment 'y' from L. Hypotheses for $x_i$ are $x_i = y$ or $x_i = M - y$. One is chosen to explore.\nb) Checking $x_i$: After adding $x_i$ to current sites X, calculate all new distances $|x_i - x_j|$ for existing $x_j \in X$. If all these new distances are present in the remaining multiset L (and can be removed), $x_i$ is satisfactory. Otherwise, backtrack.",
                answerType: 'self_assessed_descriptive', tags: ['algorithms', 'pdp', 'exam1']
            },
            {
                id: 'ex2_1c_recall', tier: 3, source: 'Exam 2, Q1c',
                questionText: "From Exam 2, Q1c (motif finding): For S=(4,5,6,7), L=5, what was the reported motif consensus string and its consensus score?",
                note: "This tests recall of the specific exam problem's answer.",
                correctAnswerDetail: "Consensus String: TCGGC\nConsensus Score: 12\n(Strength was 12/20 = 60%)",
                correctAnswerExact: "Consensus: TCGGC, Score: 12",
                answerType: 'self_assessed_descriptive', // Auto-grading is hard for combined
                tags: ['motif_finding', 'consensus_score', 'exam2']
            },
             {
                id: 'ex2_2c_recall', tier: 3, source: 'Exam 2, Q2c',
                questionText: "Recall the key steps for the brute-force median string search algorithm as described in Exam 2.",
                correctAnswerDetail: "1. `best_word = AA...A` (initial L-mer).\n2. `best_distance = infinity`.\n3. For each L-mer `word` from `AA...A` to `TT...T` (all 4^L possibilities):\n    a. Calculate `current_distance = TotalDistance(word, DNA_L_mer_set)` (sum of Hamming distances from `word` to each L-mer in the input set).\n    b. If `current_distance < best_distance`:\n        `best_distance = current_distance`\n        `best_word = word`\n4. Return `best_word`.",
                answerType: 'self_assessed_descriptive', tags: ['motif_finding', 'median_string', 'algorithms', 'exam2']
            },
            {
                id: 'ex2_5b_recall', tier: 3, source: 'Exam 2, Q5b',
                questionText: "From Exam 2, Q5b (BLASTn alignment analysis), what were the reported alignment identity (%) and alignment score?",
                note: "This tests recall of the specific exam problem's answers. Identity was noted as 23/28 or 70%. Score was 4.",
                correctAnswerDetail: "Alignment Identity (%): The student's paper noted 23/28 matches (which is ~82.14%) but also wrote '70%' as the answer.\nAlignment Score: The student's answer was 4.",
                correctAnswerExact: "Identity: 70% (or 23/28), Score: 4",
                answerType: 'self_assessed_descriptive',
                tags: ['sequence_alignment', 'blast', 'exam2']
            },
            {
                id: 'ex2_6_recall', tier: 3, source: 'Exam 2, Q6',
                questionText: "From Exam 2, Q6 (Smith-Waterman): For S=ACAA, T=CTCAT (match=+2, mis/indel=-1), what was the best local alignment and its score?",
                note: "This tests recall of the specific exam problem's answer.",
                correctAnswerDetail: "Best local alignment:\nS': CA\nT': CA\nScore: 4",
                correctAnswerExact: "Alignment: CA/CA, Score: 4",
                answerType: 'self_assessed_descriptive',
                tags: ['sequence_alignment', 'smith_waterman', 'exam2']
            },
            {
                id: 'fr_spliced_alignment_dp_concept', tier: 3, source: 'Final Review - Spliced Alignment',
                questionText: "The Final Review describes a 3D DP for Spliced Alignment: S(i, j, B). What do i, j, and B generally represent, and what does S(i, j, B) store?",
                correctAnswerDetail: "S(i, j, B) stores the score of the optimal spliced alignment.\n- 'i': Represents a prefix (up to position i) of the genomic sequence (G).\n- 'j': Represents a prefix (up to position j) of the target protein/mRNA sequence (T).\n- 'B': Represents a specific candidate exon (block) from the genomic sequence.\nThe value S(i, j, B) is the score of the optimal alignment ending such that genomic position i (within block B) is aligned with target position j, and block B is the last exon in this alignment path.",
                answerType: 'self_assessed_descriptive', tags: ['gene_prediction', 'spliced_alignment', 'dynamic_programming', 'final_review']
            },
            {
                id: 'fr_rnaseq_dz_calculation_concept', tier: 3, source: 'Final Review - RNA-seq Dead Zones',
                questionText: "From the Final Review example on dead zones (dz): If duplicated regions X and Y both have length 10, and read length is 4, how was 'a' (number of unique read start positions within one duplicated copy) calculated, and what were the resulting dz intervals if X starts at genomic position 10 and Y at 30?",
                correctAnswerDetail: "1. 'a' (number of unique read start positions in one copy, or length of the uniquely mappable part within the duplicated segment if reads must be fully contained) was calculated as: $a = |X| - |read| + 1 = 10 - 4 + 1 = 7$.\n2. $dz_1$ (for region X starting at 10): $[10, 10+a-1] = [10, 10+7-1] = [10, 16]$.\n3. $dz_2$ (for region Y starting at 30): $[30, 30+a-1] = [30, 30+7-1] = [30, 36]$.\nEach dead zone has length 'a' (7 in this case).",
                answerType: 'self_assessed_descriptive', tags: ['rna_seq', 'dead_zones', 'mappability', 'final_review']
            }
        ];

        let currentQuestionPools = [[], [], []]; // Tier 1, Tier 2, Tier 3
        let priorityReviewQueue = [];
        let currentQuestion = null;
        let currentTier = 0; // Start with Tier 1 (index 0)
        
        let questionsAnsweredInTier = 0;
        let questionsInCurrentTier = 0;

        let overallCorrectAnswers = 0;
        let overallReviewedQuestions = 0;


        const questionSourceEl = document.getElementById('questionSource');
        const questionTextEl = document.getElementById('questionText');
        const answerPromptEl = document.getElementById('answerPrompt');
        const noteAreaEl = document.getElementById('noteArea');
        const answerInputEl = document.getElementById('answerInput');
        const submitAnswerBtn = document.getElementById('submitAnswerBtn');
        const showAnswerBtn = document.getElementById('showAnswerBtn');
        const correctAnswerDisplayEl = document.getElementById('correctAnswerDisplay');
        const correctAnswerTextEl = document.getElementById('correctAnswerText');
        const selfAssessmentAreaEl = document.getElementById('self-assessment-area');
        const markCorrectBtn = document.getElementById('markCorrectBtn');
        const markIncorrectBtn = document.getElementById('markIncorrectBtn');
        const feedbackAreaEl = document.getElementById('feedbackArea');
        const nextQuestionBtn = document.getElementById('nextQuestionBtn');
        const inputAreaEl = document.getElementById('input-area');
        const skipToQuestionSelectEl = document.getElementById('skipToQuestionSelect');


        const questionProgressEl = document.getElementById('questionProgress');
        const priorityQueueSizeEl = document.getElementById('priorityQueueSize');
        const overallScoreEl = document.getElementById('overallScore');


        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function populateSkipToQuestionSelect() {
            questions.forEach((q, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `Q${index + 1}: ${q.questionText.substring(0, 30)}... (Tier ${q.tier})`;
                skipToQuestionSelectEl.appendChild(option);
            });
            skipToQuestionSelectEl.addEventListener('change', (event) => {
                const questionIndex = parseInt(event.target.value);
                jumpToQuestion(questionIndex);
            });
        }
        
        function jumpToQuestion(index) {
            if (index >= 0 && index < questions.length) {
                currentQuestion = questions[index]; // Load the chosen question directly
                 // Temporarily override normal flow for this one question
                displaySingleQuestion(currentQuestion);
            }
        }

        function displaySingleQuestion(q) {
            currentQuestion = q; // Set it as current for interactions
            feedbackAreaEl.classList.add('hidden');
            nextQuestionBtn.classList.add('hidden');
            correctAnswerDisplayEl.classList.add('hidden');
            selfAssessmentAreaEl.classList.add('hidden');
            answerInputEl.value = '';

            questionSourceEl.textContent = `Source: ${currentQuestion.source}`;
            questionTextEl.textContent = currentQuestion.questionText;
            answerPromptEl.textContent = currentQuestion.answerPrompt || (currentQuestion.answerType === 'self_assessed_descriptive' ? "Think about your answer, then click 'Show Correct Answer'." : "Type your answer above.");
            noteAreaEl.innerHTML = currentQuestion.note ? `<em>Note: ${currentQuestion.note}</em>` : "";


            if (currentQuestion.answerType === 'self_assessed_descriptive') {
                inputAreaEl.classList.add('hidden');
                showAnswerBtn.classList.remove('hidden');
                submitAnswerBtn.classList.add('hidden');
            } else if (currentQuestion.answerType === 'short_answer_exact' || currentQuestion.answerType === 'short_answer_flexible' || currentQuestion.answerType === 'short_answer_formula') {
                inputAreaEl.classList.remove('hidden');
                answerInputEl.placeholder = "Type your exact answer here";
                showAnswerBtn.classList.remove('hidden'); 
                submitAnswerBtn.classList.remove('hidden');
            }
             // Do not update regular stats here as it's a jump
        }


        function loadQuestionPools() {
            currentQuestionPools = [[], [], []];
            questions.forEach(q => {
                if (q.tier >= 1 && q.tier <= 3) {
                    currentQuestionPools[q.tier - 1].push(q);
                }
            });
            currentQuestionPools.forEach(pool => shuffleArray(pool));
            
            priorityReviewQueue = [];
            questions.forEach(q => q.incorrectlyAnswered = false);
            currentTier = 0; // Start with Tier 1
            questionsAnsweredInTier = 0;
            questionsInCurrentTier = currentQuestionPools[currentTier] ? currentQuestionPools[currentTier].length : 0;
            
            overallCorrectAnswers = 0;
            overallReviewedQuestions = 0;
            updateStats();
        }

        function displayQuestion() {
            feedbackAreaEl.classList.add('hidden');
            nextQuestionBtn.classList.add('hidden');
            correctAnswerDisplayEl.classList.add('hidden');
            selfAssessmentAreaEl.classList.add('hidden');
            answerInputEl.value = '';
            skipToQuestionSelectEl.value = questions.findIndex(q => q.id === currentQuestion?.id);


            if (priorityReviewQueue.length > 0 && (Math.random() < 0.5 || currentQuestionPools[currentTier].length === 0)) {
                currentQuestion = priorityReviewQueue.shift();
                 // Indicate it's a retry
                questionProgressEl.textContent = `Retry! (${questionsAnsweredInTier}/${questionsInCurrentTier} in Tier ${currentTier+1})`;
            } else {
                // Try to get from current tier
                if (currentQuestionPools[currentTier] && currentQuestionPools[currentTier].length > 0) {
                    currentQuestion = currentQuestionPools[currentTier].shift();
                    questionsAnsweredInTier++;
                } else {
                    // Move to next tier if current is empty
                    currentTier++;
                    questionsAnsweredInTier = 0;
                    if (currentTier < currentQuestionPools.length && currentQuestionPools[currentTier].length > 0) {
                        questionsInCurrentTier = currentQuestionPools[currentTier].length;
                        currentQuestion = currentQuestionPools[currentTier].shift();
                        questionsAnsweredInTier++;
                    } else {
                        // All tiers exhausted, check priority queue again
                        if (priorityReviewQueue.length > 0) {
                            currentQuestion = priorityReviewQueue.shift();
                             questionProgressEl.textContent = `Retry! (Wrapping up)`;
                        } else {
                            questionTextEl.textContent = "Congratulations! You've reviewed all questions. Reload to start again.";
                            showAnswerBtn.classList.add('hidden');
                            inputAreaEl.classList.add('hidden');
                            submitAnswerBtn.classList.add('hidden');
                            updateStats(); // Final update
                            return;
                        }
                    }
                }
                questionsInCurrentTier = currentQuestionPools[currentTier] ? currentQuestionPools[currentTier].length + questionsAnsweredInTier : questionsAnsweredInTier;
                questionProgressEl.textContent = `${questionsAnsweredInTier} / ${questionsInCurrentTier} (Tier ${currentTier + 1})`;
            }
            
            questionSourceEl.textContent = `Source: ${currentQuestion.source} (Tier ${currentQuestion.tier})`;
            questionTextEl.textContent = currentQuestion.questionText;
            answerPromptEl.textContent = currentQuestion.answerPrompt || (currentQuestion.answerType === 'self_assessed_descriptive' ? "Think about your answer, then click 'Show Correct Answer'." : "Type your answer above.");
            noteAreaEl.innerHTML = currentQuestion.note ? `<em>Note: ${currentQuestion.note}</em>` : "";


            if (currentQuestion.answerType === 'self_assessed_descriptive') {
                inputAreaEl.classList.add('hidden');
                showAnswerBtn.classList.remove('hidden');
                submitAnswerBtn.classList.add('hidden');
            } else if (currentQuestion.answerType === 'short_answer_exact' || currentQuestion.answerType === 'short_answer_flexible' || currentQuestion.answerType === 'short_answer_formula') {
                inputAreaEl.classList.remove('hidden');
                answerInputEl.placeholder = "Type your exact answer here";
                showAnswerBtn.classList.remove('hidden'); 
                submitAnswerBtn.classList.remove('hidden');
            }
            updateStats();
        }

        showAnswerBtn.addEventListener('click', () => {
            correctAnswerTextEl.innerHTML = currentQuestion.correctAnswerDetail.replace(/\n/g, '<br>');
            correctAnswerDisplayEl.classList.remove('hidden');
            selfAssessmentAreaEl.classList.remove('hidden');
            showAnswerBtn.classList.add('hidden');
            submitAnswerBtn.classList.add('hidden');
            inputAreaEl.classList.add('hidden');
        });

        submitAnswerBtn.addEventListener('click', () => {
            const userAnswer = answerInputEl.value.trim();
            let isCorrect = false;
            if (!currentQuestion || userAnswer === "") return; // Prevent empty submission processing

            if (currentQuestion.answerType === 'short_answer_exact') {
                isCorrect = userAnswer.toLowerCase() === currentQuestion.correctAnswerExact.toLowerCase();
            } else if (currentQuestion.answerType === 'short_answer_flexible') {
                const simplifiedUserAnswer = userAnswer.toLowerCase().replace(/[^a-z0-9\s]/g, '').replace(/\s+/g, ' ');
                const simplifiedCorrectAnswer = currentQuestion.correctAnswerExact.toLowerCase().replace(/[^a-z0-9\s]/g, '').replace(/\s+/g, ' ');
                isCorrect = simplifiedUserAnswer === simplifiedCorrectAnswer;
            } else if (currentQuestion.answerType === 'short_answer_formula') {
                isCorrect = userAnswer.replace(/\s+/g, '').toLowerCase() === currentQuestion.correctAnswerExact.replace(/\s+/g, '').toLowerCase();
            }

            feedbackAreaEl.classList.remove('hidden');
            overallReviewedQuestions++;

            if (isCorrect) {
                feedbackAreaEl.textContent = "Correct!";
                feedbackAreaEl.className = 'feedback-area feedback-correct';
                overallCorrectAnswers++;
                currentQuestion.incorrectlyAnswered = false;
                 // Remove from priority if it was there and now correct
                const indexInPriority = priorityReviewQueue.findIndex(q => q.id === currentQuestion.id);
                if (indexInPriority > -1) {
                    priorityReviewQueue.splice(indexInPriority, 1);
                }
            } else {
                feedbackAreaEl.innerHTML = `Incorrect. The expected answer includes: <span style="font-weight:normal;">${currentQuestion.correctAnswerExact || currentQuestion.correctAnswerDetail.substring(0,150)+'...'}</span><br>This will be asked again.`;
                feedbackAreaEl.className = 'feedback-area feedback-incorrect';
                if (currentQuestion.id && !currentQuestion.incorrectlyAnswered) { 
                    currentQuestion.incorrectlyAnswered = true;
                    priorityReviewQueue.push(currentQuestion); 
                    shuffleArray(priorityReviewQueue);
                } else if (currentQuestion.id && currentQuestion.incorrectlyAnswered && !priorityReviewQueue.find(q => q.id === currentQuestion.id)) {
                    // If it was already marked incorrect but somehow not in queue (e.g. after a skip), re-add
                    priorityReviewQueue.push(currentQuestion);
                    shuffleArray(priorityReviewQueue);
                }
            }
            correctAnswerTextEl.innerHTML = currentQuestion.correctAnswerDetail.replace(/\n/g, '<br>');
            correctAnswerDisplayEl.classList.remove('hidden');
            nextQuestionBtn.classList.remove('hidden');
            submitAnswerBtn.classList.add('hidden');
            selfAssessmentAreaEl.classList.add('hidden'); 
            updateStats();
        });

        markCorrectBtn.addEventListener('click', () => {
            feedbackAreaEl.textContent = "Great! Marked as correct.";
            feedbackAreaEl.className = 'feedback-area feedback-correct';
            feedbackAreaEl.classList.remove('hidden');
            
            overallCorrectAnswers++;
            overallReviewedQuestions++;
            currentQuestion.incorrectlyAnswered = false;
            const indexInPriority = priorityReviewQueue.findIndex(q => q.id === currentQuestion.id);
            if (indexInPriority > -1) {
                priorityReviewQueue.splice(indexInPriority, 1);
            }
            finalizeQuestionHandling();
        });

        markIncorrectBtn.addEventListener('click', () => {
            feedbackAreaEl.textContent = "No problem! This question will be added to your priority review queue for more practice.";
            feedbackAreaEl.className = 'feedback-area feedback-incorrect';
            feedbackAreaEl.classList.remove('hidden');
            overallReviewedQuestions++;
            
            if (currentQuestion.id && !currentQuestion.incorrectlyAnswered) { 
                currentQuestion.incorrectlyAnswered = true;
                priorityReviewQueue.push(currentQuestion); 
                shuffleArray(priorityReviewQueue);
            }  else if (currentQuestion.id && currentQuestion.incorrectlyAnswered && !priorityReviewQueue.find(q => q.id === currentQuestion.id)) {
                priorityReviewQueue.push(currentQuestion); // Re-add if it was somehow missed
                shuffleArray(priorityReviewQueue);
            }
            finalizeQuestionHandling();
        });
        
        function finalizeQuestionHandling() {
            selfAssessmentAreaEl.classList.add('hidden');
            nextQuestionBtn.classList.remove('hidden');
            updateStats();
        }

        nextQuestionBtn.addEventListener('click', () => {
            // Reset skip dropdown to placeholder or current question if that makes sense
            // skipToQuestionSelectEl.selectedIndex = 0; // Or find current actual index
            displayQuestion();
        });

        function updateStats() {
            // questionProgressEl is updated within displayQuestion for tier progress
            priorityQueueSizeEl.textContent = priorityReviewQueue.length;
            overallScoreEl.textContent = `${overallCorrectAnswers} / ${overallReviewedQuestions}`;
        }

        // Initialize
        populateSkipToQuestionSelect();
        loadQuestionPools();
        displayQuestion(); // Initial question display
    </script>
</body>
</html>
